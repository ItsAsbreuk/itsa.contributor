<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/dom-ext/lib/element.js - Itsa</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Itsa"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Array.html">Array</a></li>
            
                <li><a href="../classes/DD.html">DD</a></li>
            
                <li><a href="../classes/document.html">document</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/Event.Emitter.html">Event.Emitter</a></li>
            
                <li><a href="../classes/Event.Listener.html">Event.Listener</a></li>
            
                <li><a href="../classes/Function.html">Function</a></li>
            
                <li><a href="../classes/IO.html">IO</a></li>
            
                <li><a href="../classes/ITSA.html">ITSA</a></li>
            
                <li><a href="../classes/NodeList.html">NodeList</a></li>
            
                <li><a href="../classes/NodePlugin.html">NodePlugin</a></li>
            
                <li><a href="../classes/Object.html">Object</a></li>
            
                <li><a href="../classes/Promise.html">Promise</a></li>
            
                <li><a href="../classes/String.html">String</a></li>
            
                <li><a href="../classes/Utils.html">Utils</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/dom-ext.html">dom-ext</a></li>
            
                <li><a href="../modules/drag.html">drag</a></li>
            
                <li><a href="../modules/drag-drop.html">drag-drop</a></li>
            
                <li><a href="../modules/event.html">event</a></li>
            
                <li><a href="../modules/event-dom.html">event-dom</a></li>
            
                <li><a href="../modules/event-emitter.html">event-emitter</a></li>
            
                <li><a href="../modules/event-hover.html">event-hover</a></li>
            
                <li><a href="../modules/event-listener.html">event-listener</a></li>
            
                <li><a href="../modules/event-mobile.html">event-mobile</a></li>
            
                <li><a href="../modules/io.html">io</a></li>
            
                <li><a href="../modules/io-assets.html">io-assets</a></li>
            
                <li><a href="../modules/io-cors.html">io-cors</a></li>
            
                <li><a href="../modules/io-jsonp.html">io-jsonp</a></li>
            
                <li><a href="../modules/io-transfer.html">io-transfer</a></li>
            
                <li><a href="../modules/io-xml.html">io-xml</a></li>
            
                <li><a href="../modules/itsa.build.html">itsa.build</a></li>
            
                <li><a href="../modules/js-ext.html">js-ext</a></li>
            
                <li><a href="../modules/lib_array.js.html">lib/array.js</a></li>
            
                <li><a href="../modules/lib_document.js.html">lib/document.js</a></li>
            
                <li><a href="../modules/lib_element-plugin.js.html">lib/element-plugin.js</a></li>
            
                <li><a href="../modules/lib_element.js.html">lib/element.js</a></li>
            
                <li><a href="../modules/lib_function.js.html">lib/function.js</a></li>
            
                <li><a href="../modules/lib_nodelist.js.html">lib/nodelist.js</a></li>
            
                <li><a href="../modules/lib_object.js.html">lib/object.js</a></li>
            
                <li><a href="../modules/lib_promise.s.html">lib/promise.s</a></li>
            
                <li><a href="../modules/lib_string.js.html">lib/string.js</a></li>
            
                <li><a href="../modules/node-win.html">node-win</a></li>
            
                <li><a href="../modules/utils.html">utils</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/dom-ext/lib/element.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

/**
 * Integrates DOM-events to event. more about DOM-events:
 * http://www.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/
 *
 *
 * &lt;i&gt;Copyright (c) 2014 ITSA - https://github.com/itsa&lt;/i&gt;
 * New BSD License - http://choosealicense.com/licenses/bsd-3-clause/
 *
 * @example
 * require(&#x27;dom-ext/lib/element.js&#x27;)(window);
 *
 * @module dom-ext
 * @submodule lib/element.js
 * @class Element
 * @since 0.0.1
*/

module.exports = function (window) {

    var NAME = &#x27;[dom-ext]: &#x27;,
        POSITION = &#x27;position&#x27;,
        BLOCK = &#x27;el-block&#x27;,
        BORDERBOX = &#x27;el-borderbox&#x27;,
        NO_TRANS = &#x27;el-notrans&#x27;,
        INVISIBLE = &#x27;el-invisible&#x27;,
        REGEXP_NODE_ID = /^#\S+$/,
        RESERVED_WORDS = require(&#x27;js-ext/extra/reserved-words.js&#x27;),
        APPEND_CHILD = &#x27;appendChild&#x27;,
        INSERT_BEFORE = &#x27;insertBefore&#x27;,
        LEFT = &#x27;left&#x27;,
        TOP = &#x27;top&#x27;,
        BORDER = &#x27;border&#x27;,
        WIDTH = &#x27;width&#x27;,
        BORDER_LEFT_WIDTH = BORDER+&#x27;-left-&#x27;+WIDTH,
        BORDER_RIGHT_WIDTH = BORDER+&#x27;-right-&#x27;+WIDTH,
        BORDER_TOP_WIDTH = BORDER+&#x27;-top-&#x27;+WIDTH,
        BORDER_BOTTOM_WIDTH = BORDER+&#x27;-bottom-&#x27;+WIDTH,
        NUMBER = &#x27;number&#x27;,
        PX = &#x27;px&#x27;,
        toCamelCase = function(input) {
            return input.toLowerCase().replace(/-(.)/g, function(match, group) {
                return group.toUpperCase();
            });
        };

    window.Element &amp;&amp; (function(ElementPrototype) {

        require(&#x27;../css/element.css&#x27;);
        require(&#x27;js-ext/lib/string.js&#x27;);
        require(&#x27;js-ext/lib/object.js&#x27;);
        require(&#x27;./document.js&#x27;)(window);
        require(&#x27;polyfill/lib/array.isarray.js&#x27;);
        require(&#x27;polyfill/lib/array.every.js&#x27;);
        require(&#x27;polyfill/lib/element.matchesselector.js&#x27;);
        require(&#x27;window-ext&#x27;)(window);

        var documentElement = window.document.documentElement;

       /**
        * Appends a HtmlElement or text at the end of HtmlElement&#x27;s innerHTML, or before the &#x60;refElement&#x60;.
        *
        * @method append
        * @param content {HtmlElement|HtmlElementList|String} content to append
        * @param [refElement] {HtmlElement|HtmlElementList|String} reference Element where the content should be appended
        * @param [escape] {Boolean} whether to insert &#x60;escaped&#x60; content, leading it into only text inserted
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.append = function(content, refElement, escape) {
            refElement &amp;&amp; (this.children.indexOf(refElement)!==-1) &amp;&amp; (refElement=refElement.next());
            return window.document._insert(this, refElement ? INSERT_BEFORE : APPEND_CHILD, content, refElement, escape);
        };

       /**
        * Returns a duplicate of the node. Use cloneNode(true) for a &#x60;deep&#x60; clone.
        * Almost the same as native cloneNode(), but you should use clone(), because it also clones any data set with setData().
        *
        * @method clone
        * @param content {HtmlElement|HtmlElementList|String} content to append. In case of HTML, it will be escaped.
        * @param [deep] {Boolean} whether to perform a &#x60;deep&#x60; clone: with all descendants
        * @return {HtmlElement} a clone of this HtmlElement
        * @since 0.0.1
        */
        ElementPrototype.clone = function(deep) {
            var instance = this,
                cloned = instance.cloneNode(deep);
            if (instance._data) {
                Object.defineProperty(cloned, &#x27;_data&#x27;, {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: {} // &#x60;writable&#x60; is false means we cannot chance the value-reference, but we can change {}&#x27;s properties itself
                });
                cloned._data.merge(instance._data);
            }
            return cloned;
        };

       /**
        * Sets the inline-style of the HtmlElement exactly to the specified &#x60;value&#x60;, overruling previous values.
        * Making the HtmlElement&#x27;s inline-style look like: style=&quot;value&quot;.
        *
        * This is meant for a quick one-time setup. For individually inline style-properties to be set, you can use &#x60;setInlineStyle()&#x60;.
        *
        * @method defineInlineStyle
        * @param value {String} the style string to be set
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.defineInlineStyle = function(value) {
            this.style.cssText = value;
            return this;
        };

       /**
        * Empties the content of the HtmlElement.
        * Alias for setText(&#x27;&#x27;);
        *
        * @method empty
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.empty = function(/* cssSelector */) {
            return this.setText(&#x27;&#x27;);
        };

       /**
        * Returns the first of the HtmlElement&#x27;s siblings, or the first that matches &#x60;cssSelector&#x60;.
        *
        * @method first
        * @param [cssSelector] {String} css-selector to be used as a filter
        * @return {HtmlElement|null}
        * @since 0.0.1
        */
        ElementPrototype.first = function(/* cssSelector */) {
            return window.document.first.apply(this, arguments);
        };

       /**
        * Forces the HtmlElement to be inside an ancestor-HtmlElement that has the &#x60;overfow=&quot;scroll&quot; set.
        *
        * @method forceIntoNodeView
        * @param [ancestor] {HtmlElement} the HtmlElement where it should be forced into its view.
        *        Only use this when you know the ancestor and this ancestor has an &#x60;overflow=&quot;scroll&quot;&#x60; property
        *        when not set, this method will seek through the doc-tree upwards for the first HtmlElement that does match this criteria.
        * @chainable
        * @since 0.0.2
        */
        ElementPrototype.forceIntoNodeView = function(ancestor) {
            console.log(NAME, &#x27;forceIntoNodeView&#x27;);
            var instance = this,
                parentOverflowNode = this.parentNode,
                match, left, width, right, height, top, bottom, scrollLeft, scrollTop, parentOverflowNodeX, parentOverflowNodeY,
                parentOverflowNodeStartTop, parentOverflowNodeStartLeft, parentOverflowNodeStopRight, parentOverflowNodeStopBottom, newX, newY;
            if (ancestor) {
                parentOverflowNode = ancestor;
            }
            else {
                while ((parentOverflowNode!==window.document) &amp;&amp; !(match=(parentOverflowNode.getStyle(&#x27;overflow&#x27;)===&#x27;scroll&#x27;))) {
                    parentOverflowNode = parentOverflowNode.parentNode;
                }
            }
            if (parentOverflowNode!==window.document) {
                left = instance.getX();
                width = instance.offsetWidth;
                right = left + width;
                height = instance.offsetHeight;
                top = instance.getY();
                bottom = top + height;
                scrollLeft = parentOverflowNode.getScrollLeft();
                scrollTop = parentOverflowNode.getScrollTop();
                parentOverflowNodeX = parentOverflowNode.getX();
                parentOverflowNodeY = parentOverflowNode.getY();
                parentOverflowNodeStartTop = parentOverflowNodeY+parseInt(parentOverflowNode.getStyle(BORDER_TOP_WIDTH), 10);
                parentOverflowNodeStartLeft = parentOverflowNodeX+parseInt(parentOverflowNode.getStyle(BORDER_LEFT_WIDTH), 10);
                parentOverflowNodeStopRight = parentOverflowNodeX+parentOverflowNode.offsetWidth-parseInt(parentOverflowNode.getStyle(BORDER_RIGHT_WIDTH), 10);
                parentOverflowNodeStopBottom = parentOverflowNodeY+parentOverflowNode.offsetHeight-parseInt(parentOverflowNode.getStyle(BORDER_BOTTOM_WIDTH), 10);

                if (left&lt;parentOverflowNodeStartLeft) {
                    newX = Math.max(0, scrollLeft+left-parentOverflowNodeStartLeft);
                }
                else if (right&gt;parentOverflowNodeStopRight) {
                    newX = scrollLeft + right - parentOverflowNodeStopRight;
                }

                if (top&lt;parentOverflowNodeStartTop) {
                    newY = Math.max(0, scrollTop+top-parentOverflowNodeStartTop);
                }
                else if (bottom&gt;parentOverflowNodeStopBottom) {
                    newY = scrollTop + bottom - parentOverflowNodeStopBottom;
                }

                if ((newX!==undefined) || (newY!==undefined)) {
                    parentOverflowNode.scrollTo((newX!==undefined) ? newX : scrollLeft,(newY!==undefined) ? newY : scrollTop);
                }
            }
            return instance;
        };

       /**
        * Forces the HtmlElement to be inside the window-view. Differs from &#x60;scrollIntoView()&#x60; in a way
        * that &#x60;forceIntoView()&#x60; doesn&#x27;t change the position when it&#x27;s inside the view, whereas
        * &#x60;scrollIntoView()&#x60; sets it on top of the view.
        *
        * @method forceIntoView
        * @param [notransition=false] {Boolean} set true if you are sure positioning is without transition.
        *        this isn&#x27;t required, but it speeds up positioning. Only use when no transition is used:
        *        when there is a transition, setting this argument &#x60;true&#x60; would miscalculate the position.
        * @param [rectangle] {Object} Set this if you have already calculated the window-rectangle (used for preformance within drag-drop)
        * @param [rectangle.x] {Number} scrollLeft of window
        * @param [rectangle.y] {Number} scrollTop of window
        * @param [rectangle.w] {Number} width of window
        * @param [rectangle.h] {Number} height of window
        * @chainable
        * @since 0.0.2
        */
        ElementPrototype.forceIntoView = function(notransition, rectangle) {
            console.log(NAME, &#x27;forceIntoView&#x27;);
            var instance = this,
                left = instance.getX(),
                width = instance.offsetWidth,
                right = left + width,
                height = instance.offsetHeight,
                top = instance.getY(),
                bottom = top + height,
                windowLeft, windowTop, windowRight, windowBottom, newX, newY;
            if (rectangle) {
                windowLeft = rectangle.x;
                windowTop = rectangle.y;
                windowRight = rectangle.w;
                windowBottom = rectangle.h;
            }
            else {
                windowLeft = window.getScrollLeft();
                windowTop = window.getScrollTop();
                windowRight = windowLeft + window.getWidth();
                windowBottom = windowTop + window.getHeight();
            }

            if (left&lt;windowLeft) {
                newX = Math.max(0, left);
            }
            else if (right&gt;windowRight) {
                newX = windowLeft + right - windowRight;
            }
            if (top&lt;windowTop) {
                newY = Math.max(0, top);
            }
            else if (bottom&gt;windowBottom) {
                newY = windowTop + bottom - windowBottom;
            }

            if ((newX!==undefined) || (newY!==undefined)) {
                window.scrollTo((newX!==undefined) ? newX : windowLeft, (newY!==undefined) ? newY : windowTop);
            }
            return instance;
        };

       /**
        * Gets a NodeList of HtmlElements, specified by the css-selector.
        *
        * @method getAll
        * @param cssSelector {String} css-selector to match
        * @return {NodeList} NodeList of HtmlElements that match the css-selector
        * @since 0.0.1
        */
        ElementPrototype.getAll = function(/* cssSelector */) {
            return window.document.getAll.apply(this, arguments);
        };

       /**
        * Gets an attribute of the HtmlElement.
        * Cautious: do not use &#x60;value&#x60; to retrieve the value. Use &#x60;getValue()&#x60; instead.
        *
        * Alias for getAttribute().
        *
        * @method getAttr
        * @param attributeName {String}
        * @return {String|null} value of the attribute
        * @since 0.0.1
        */
        ElementPrototype.getAttr = function(/* attributeName */) {
            return this.getAttribute.apply(this, arguments);
        };

       /**
        * Gets the HtmlElement&#x27;s class as a whole String.
        *
        * Alias for this.className
        *
        * @method getClass
        * @return {String} The complete class of the HtmlElement as a String
        * @since 0.0.1
        */
        ElementPrototype.getClass = function() {
            return this.className;
        };

       /**
        * Returns data set specified by &#x60;key&#x60;. If not set, &#x60;undefined&#x60; will be returned.
        *
        * @method getData
        * @param key {string} name of the key
        * @return {Any|undefined} data set specified by &#x60;key&#x60;
        * @since 0.0.1
        */
        ElementPrototype.getData = function(key) {
            return this._data &amp;&amp; this._data[key];
        };

       /**
        * Gets one HtmlElement, specified by the css-selector. To retrieve a single element by id,
        * you need to prepend the id-name with a &#x60;#&#x60;. When multiple HtmlElement&#x27;s match, the first is returned.
        *
        * @method getElement
        * @param cssSelector {String} css-selector to match
        * @return {HtmlElement|null} the HtmlElement that was search for
        * @since 0.0.1
        */
        ElementPrototype.getElement = function(/* cssSelector */) {
            return window.document.getElement.apply(this, arguments);
        };

       /**
        * Gets the height of the element in pixels. Included are padding and border, not any margins.
        * By setting the argument &#x60;overflow&#x60; you get the total height, included the invisible overflow.
        *
        * @method getHeight
        * @param [overflow=false] {Boolean} in case of elements that overflow: return total height, included the invisible overflow
        * @return {Number} width in pixels
        * @since 0.0.1
        */
        ElementPrototype.getHeight = function(overflow) {
            return overflow ? this.scrollHeight : this.offsetHeight;
        };

       /**
        * Returns the innerContent of the HtmlElement as a string with HTML entities.
        *
        * Alias for innerHTML
        *
        * @method getHtml
        * @return {String} content as a string with HTML entities
        * @since 0.0.1
        */
        ElementPrototype.getHtml = function() {
            return this.innerHTML;
        };

       /**
        * Gets the HtmlElement&#x27;s id.
        *
        * Alias for this.id
        *
        * @method getId
        * @return {String} The id of the HtmlElement (=== &#x27;&#x27;) when undefined
        * @since 0.0.1
        */
        ElementPrototype.getId = function() {
            return this.id;
        };

       /**
        * Returns inline style of the specified property. &#x60;Inline&#x60; means: what is set directly on the HtmlElement,
        * this doesn&#x27;t mean necesairy how it is looked like: when no css is set inline, the HtmlElement might still have
        * an appearance because of other CSS-rules.
        *
        * In most cases, you would be interesting in using &#x60;getStyle()&#x60; instead.
        *
        * Note: no need to camelCase cssProperty: both &#x60;margin-left&#x60; as well as &#x60;marginLeft&#x60; are fine
        *
        * @method getInlineStyle
        * @return {String} content as a string with HTML entities
        * @since 0.0.1
        */
        ElementPrototype.getInlineStyle = function(cssProperty) {
            return this.style[toCamelCase(cssProperty)];
        };

        /**
         * Gets the left-scroll offset of the content of the HtmlElement.
         * Only apropriate when the HtmlElement has overflow.
         *
         * @method getScrollLeft
         * @return {Number} left-offset in pixels
         * @since 0.0.1
        */
        ElementPrototype.getScrollLeft = function() {
            return this.scrollLeft;
        };

        /**
         * Gets the top-scroll offset of the content of the HtmlElement.
         * Only apropriate when the HtmlElement has overflow.
         *
         * @method getScrollTop
         * @return {Number} top-offset in pixels
         * @since 0.0.1
        */
        ElementPrototype.getScrollTop = function() {
            return this.scrollTop;
        };

       /**
        * Returns cascaded style of the specified property. &#x60;Cascaded&#x60; means: the actual present style,
        * the way it is visible (calculated through the DOM-tree).
        *
        * Note1: values are absolute: percentages and points are converted to absolute values, sizes are in pixels, colors in rgb/rgba-format.
        * Note2: you cannot query shotcut-properties: use &#x60;margin-left&#x60; instead of &#x60;margin&#x60;.
        * Note3: no need to camelCase cssProperty: both &#x60;margin-left&#x60; as well as &#x60;marginLeft&#x60; are fine.
        *
        * @method getCascadeStyle
        * @param cssProperty {String} property that is queried
        * @param [pseudo] {String} to query pseudo-element, fe: &#x60;:before&#x60; or &#x60;:first-line&#x60;
        * @return {String} value for the css-property
        * @since 0.0.1
        */
        ElementPrototype.getStyle = function(cssProperty, pseudo) {
            return window.getComputedStyle(this, pseudo)[toCamelCase(cssProperty)];
        };

       /**
        * Gets the HtmlElement&#x27;s tagname. Always uppercased.
        *
        * Alias for this.nodeName
        *
        * @method getTag
        * @return {String} The tag-name of the HtmlElement in uppercase
        * @since 0.0.1
        */
        ElementPrototype.getTag = function() {
            return this.nodeName;
        };

       /**
        * Gets the text content of the HtmlElement and its descendants.
        * If you need full HTML, you should use getHTML().
        *
        * Alias for textContent
        *
        * @method getText
        * @return {String} content of the HtmlElement as text
        * @since 0.0.1
        */
        ElementPrototype.getText = function() {
            var instance = this;
            if (documentElement.textContent) {
                return instance.textContent;
            }
            // now we are in IE8-, but it might not return the same as textContent
            // (see https://developer.mozilla.org/en-US/docs/Web/API/Node.textContent)
            // We accept this for it will be an edgecase we might never run into
            // and we prefer to keep the code lightweight
            return instance.innerText;
        };

       /**
        * Gets the width of the element in pixels. Included are padding and border, not any margins.
        * By setting the argument &#x60;overflow&#x60; you get the total width, included the invisible overflow.
        *
        * @method getWidth
        * @param [overflow=false] {Boolean} in case of elements that overflow: return total width, included the invisible overflow
        * @return {Number} width in pixels
        * @since 0.0.1
        */
        ElementPrototype.getWidth = function(overflow) {
            return overflow ? this.scrollWidth : this.offsetWidth;
        };

       /**
        * Gets the value of the following HtmlElements:
        *
        * &lt;ul&gt;
        *     &lt;li&gt;input&lt;/li&gt;
        *     &lt;li&gt;textarea&lt;/li&gt;
        *     &lt;li&gt;select&lt;/li&gt;
        *     &lt;li&gt;any container that is &#x60;contenteditable&#x60;&lt;/li&gt;
        *
        * @method getValue
        * @return {String|null} value of the attribute
        * @since 0.0.1
        */
        ElementPrototype.getValue = function() {
            // cautious: input and textarea must be accessed by their propertyname:
            // input.getAttribute(&#x27;value&#x27;) would return the defualt-value instead of actusl
            // and textarea.getAttribute(&#x27;value&#x27;) doesn&#x27;t exist
            var editable = ((editable=this.getAttr(&#x27;contenteditable&#x27;)) &amp;&amp; (editable!==&#x27;false&#x27;));
            return editable ? this.innerHTML : this.value;
        };

       /**
        * Gets the x-position (in the window.document) of the element in pixels.
        * window.document-related: regardless of the window&#x27;s scroll-position.
        *
        * @method getX
        * @return {Number} x-position in pixels
        * @since 0.0.1
        */
        ElementPrototype.getX = function() {
            return this.getBoundingClientRect().left + window.getScrollLeft();
        };

       /**
        * Gets the y-position (in the window.document) of the element in pixels.
        * window.document-related: regardless of the window&#x27;s scroll-position.
        *
        * @method getY
        * @return {Number} y-position in pixels
        * @since 0.0.1
        */
        ElementPrototype.getY = function() {
            return this.getBoundingClientRect().top + window.getScrollTop();
        };

       /**
        * Whether the HtmlElement has the attribute set.
        *
        * Alias for hasAttribute().
        *
        * @method hasAttr
        * @param attributeName {String}
        * @return {Boolean} Whether the HtmlElement has the attribute set.
        * @since 0.0.1
        */
        ElementPrototype.hasAttr = function(/* attributeName */) {
            return this.hasAttribute.apply(this, arguments);
        };

       /**
        * Checks whether the className is present on the Element.
        *
        * @method hasClass
        * @param className {String|Array} the className to check for. May be an Array of classNames.
        * @return {Boolean} whether the className (or classNames) is present on the Element
        * @since 0.0.1
        */
        ElementPrototype.hasClass = function(className) {
            var instance = this,
                check = function(cl) {
                    var regexp = new RegExp(&#x27;\\b&#x27; + cl + &#x27;\\b&#x27;);
                    return regexp.test(instance.className);
                };
            if (typeof className === &#x27;string&#x27;) {
                return check(className);
            }
            else if (Array.isArray(className)) {
                return className.every(check);
            }
            return false;
        };

       /**
        * If the Element has data set specified by &#x60;key&#x60;.
        *
        * @method hasData
        * @param key {string} name of the key
        * @return {Boolean}
        * @since 0.0.1
        */
        ElementPrototype.hasData = function(key) {
            return !!this._data &amp;&amp; !!this._data[key];
        };

       /**
        * Checks whether HtmlElement currently has the focus.
        *
        * @method hasFocus
        * @param newHtmlElement {HtmlElement} the new HtmlElement
        * @return {Boolean} whether the className is present on the Element
        * @since 0.0.1
        */
        ElementPrototype.hasFocus = function() {
            return (window.document.activeElement===this);
        };

       /**
         * Checks whether the HtmlElement lies within the specified selector (which can be a CSS-selector or a HtmlElement)
         *
         * @method inside
         * @param selector {HtmlElement|String} the selector, specified by a Node or a css-selector
         * @return {HtmlElement|null} the nearest HtmlElement that matches the selector, or &#x60;null&#x60; when not found
         * @since 0.0.2
         */
        ElementPrototype.inside = function(selector) {
            var instance = this,
                parentNode;
            if (typeof selector===&#x27;string&#x27;) {
                parentNode = instance.parentNode;
                while ((parentNode!==window.document) &amp;&amp; !parentNode.matchesSelector(selector)) {
                    parentNode = parentNode.parentNode;
                }
                return (parentNode!==window.document) ? parentNode : null;
            }
            else {
                // selector should be an HtmlElement
                return ((selector!==instance) &amp;&amp; selector.contains(instance)) ? selector : null;
            }
        };

       /**
         * Checks whether a point specified with x,y is within the HtmlElement&#x27;s region.
         *
         * @method insidePos
         * @param x {Number} x-value for new position (coordinates are page-based)
         * @param y {Number} y-value for new position (coordinates are page-based)
         * @since 0.0.2
         */
        ElementPrototype.insidePos = function(x, y) {
            var instance = this,
                left = instance.getX(),
                top = instance.getY(),
                right = left + instance.offsetWidth,
                bottom = top + instance.offsetHeight;
            return (x&gt;=left) &amp;&amp; (x&lt;=right) &amp;&amp; (y&gt;=top) &amp;&amp; (y&lt;=bottom);
        };

       /**
        * Returns the last of the HtmlElement&#x27;s siblings, or the last that matches &#x60;cssSelector&#x60;.
        *
        * @method last
        * @param [cssSelector] {String} css-selector to be used as a filter
        * @return {HtmlElement|null}
        * @since 0.0.1
        */
        ElementPrototype.last = function(/* cssSelector */) {
            return window.document.last.apply(this, arguments);
        };

       /**
        * Returns the next of the HtmlElement&#x27;s siblings, or the next that matches &#x60;cssSelector&#x60;.
        *
        * @method next
        * @param [cssSelector] {String} css-selector to be used as a filter
        * @return {HtmlElement|null}
        * @since 0.0.1
        */
        ElementPrototype.next = function(cssSelector) {
            var found, nextElement;
            if (!cssSelector) {
                return this.nextElementSibling;
            }
/*jshint noempty:true */
            while ((nextElement=this.nextElementSibling) &amp;&amp; (found=nextElement.matchesSelector(cssSelector))) {}
/*jshint noempty:false */
            return found &amp;&amp; nextElement;
        };

       /**
        * Prepends a HtmlElement or text at the start of HtmlElement&#x27;s innerHTML, or before the &#x60;refElement&#x60;.
        *
        * @method prepend
        * @param content {HtmlElement|HtmlElementList|String} content to prepend
        * @param [refElement] {HtmlElement|HtmlElementList|String} reference Element where the content should be prepended
        * @param [escape] {Boolean} whether to insert &#x60;escaped&#x60; content, leading it into only text inserted
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.prepend = function(content, refElement, escape) {
            var instance = this,
                children = instance.children;
            if (children.length===0) {
                return instance.window.document._insert(instance, APPEND_CHILD, content, null, escape);
            }
            return instance.window.document._insert(instance, INSERT_BEFORE, content, (refElement &amp;&amp; (children.indexOf(refElement)!==-1)) ? refElement : children[0], escape);
        };

       /**
        * Returns the previous of the HtmlElement&#x27;s siblings, or the previous that matches &#x60;cssSelector&#x60;.
        *
        * @method prev
        * @param [cssSelector] {String} css-selector to be used as a filter
        * @return {HtmlElement|null}
        * @since 0.0.1
        */
        ElementPrototype.prev = function(cssSelector) {
            var found, previousElement;
            if (!cssSelector) {
                return this.previousElementSibling;
            }
/*jshint noempty:true */
            while ((previousElement=this.previousElementSibling) &amp;&amp; (found=previousElement.matchesSelector(cssSelector))) {}
/*jshint noempty:false */
            return found &amp;&amp; previousElement;
        };

       /**
         * Checks whether the HtmlElement has its rectangle inside the outboud-Element.
         * This is no check of the DOM-tree, but purely based upon coordinates.
         *
         * @method rectangleInside
         * @param outboundElement {HtmlElement} the Element where this element should lie inside
         * @return {Boolean} whether the Element lies inside the outboundElement
         * @since 0.0.2
         */
        ElementPrototype.rectangleInside = function(outboundElement) {
            var instance = this,
                outerRect = outboundElement.getBoundingClientRect(),
                innerRect = instance.getBoundingClientRect();
            return (outerRect.left&lt;=innerRect.left) &amp;&amp;
                   (outerRect.top&lt;=innerRect.top) &amp;&amp;
                   ((outerRect.left+outboundElement.offsetWidth)&gt;=(innerRect.left+instance.offsetWidth)) &amp;&amp;
                   ((outerRect.top+outboundElement.offsetHeight)&gt;=(innerRect.top+instance.offsetHeight));
        };

       /**
        * Removes the HtmlElement from the DOM.
        *
        * @method remove
        * @since 0.0.1
        */
        ElementPrototype.remove = function() {
            var parent = this.parentNode;
            parent &amp;&amp; parent.removeChild(this);
        };

       /**
        * Removes the attribute from the HtmlElement.
        *
        * Alias for removeAttribute().
        *
        * @method removeAttr
        * @param attributeName {String}
        * @return {Boolean} Whether the HtmlElement has the attribute set.
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeAttr = function(/* attributeName */) {
            this.removeAttribute.apply(this, arguments);
            return this;
        };

       /**
        * Removes a className from the HtmlElement.
        *
        * @method removeClass
        * @param className {String|Array} the className that should be removed. May be an Array of classNames.
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeClass = function(className) {
            var instance = this,
                doRemove = function(cl) {
                    var regexp = new RegExp(&#x27;(?:^|\\s+)&#x27; + cl + &#x27;(?:\\s+|$)&#x27;, &#x27;g&#x27;);
                    instance.className = instance.className.replace(regexp, &#x27; &#x27;).trim();
                };
            if (typeof className === &#x27;string&#x27;) {
                doRemove(className);
            }
            else if (Array.isArray(className)) {
                className.forEach(doRemove);
            }
            (instance.className===&#x27;&#x27;) &amp;&amp; instance.removeAttr(&#x27;class&#x27;);
            return instance;
        };

       /**
        * Removes data specified by &#x60;key&#x60;. When no arguments are passed, all node-data (key-value pairs) will be removed.
        *
        * @method removeData
        * @param key {string} name of the key
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeData = function(key) {
            var instance = this;
            if (instance._data) {
                if (key) {
                    delete instance._data[key];
                }
                else {
                    // we cannot just redefine _data, for it is set as readonly
                    instance._data.each(
                        function(value, key) {
                            delete instance._data[key];
                        }
                    );
                }
            }
            return instance;
        };

       /**
        * Removes a css-property (inline) out of the HtmlElement. Use camelCase.
        *
        * @method removeInlineStyle
        * @param cssAttribute {String} the css-property to be removed
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.removeInlineStyle = function(cssAttribute) {
            this.setInlineStyle(cssAttribute, &#x27;&#x27;);
            return this;
        };

       /**
        * Replaces the HtmlElement with a new HtmlElement.
        *
        * @method replace
        * @param newHtmlElement {HtmlElement|String} the new HtmlElement
        * @param [escape] {Boolean} whether to insert &#x60;escaped&#x60; content, leading it into only text inserted
        * @since 0.0.1
        */
        ElementPrototype.replace = function(newHtmlElement, escape) {
            window.document.replace(this, newHtmlElement, escape);
        };

       /**
        * Replaces the className of the HtmlElement with a new className.
        * If the previous className is not available, the new className is set nevertheless.
        *
        * @method replaceClass
        * @param prevClassName {String} the className to be replaced
        * @param newClassName {String} the className to be set
        * @param [force ] {Boolean} whether the new className should be set, even is the previous className isn&#x27;t there
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.replaceClass = function(prevClassName, newClassName, force) {
            var instance = this;
            if (force || instance.hasClass(prevClassName)) {
                instance.removeClass(prevClassName).setClass(newClassName);
            }
            return instance;
        };

        /**
         * Scrolls the content of the HtmlElement into the specified scrollposition.
         * Only available when the HtmlElement has overflow.
         *
         * @method scrollTo
         * @param x {Number} left-offset in pixels
         * @param y {Number} top-offset in pixels
         * @chainable
         * @since 0.0.1
        */
        ElementPrototype.scrollTo = function(x, y) {
            var instance = this;
            instance.scrollLeft = x;
            instance.scrollTop = y;
            return instance;
        };

       /**
        * Gets the serialized HTML fragment describing the element including its descendants.
        *
        * alias for outerHTML()
        *
        * @method serialize
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.serialize = function() {
            return this.outerHTML;
        };

       /**
         * Sets the attribute on the HtmlElement with the specified value.
         *
         * Alias for setAttribute().
         *
         * @method setAttr
         * @param attributeName {String}
         * @param value {Any} the value that belongs to &#x60;key&#x60;
         * @chainable
         * @since 0.0.1
        */
        ElementPrototype.setAttr = function(attributeName, value) {
            this.setAttribute.call(this, attributeName, value || &#x27;&#x27;);
            return this;
        };

       /**
        * Adds a class to the HtmlElement. If the class already exists it won&#x27;t be duplicated.
        *
        * @method setClass
        * @param className {String|Array} className to be added, may be an array of classNames
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.setClass = function(className) {
            var instance = this,
                doSet = function(cl) {
                    instance.hasClass(cl) || (instance.className += ((instance.className.length&gt;0) ? &#x27; &#x27; : &#x27;&#x27;) + cl);
                };
            if (typeof className === &#x27;string&#x27;) {
                doSet(className);
            }
            else if (Array.isArray(className)) {
                className.forEach(doSet);
            }
            return instance;
        };

       /**
        * Sets the HtmlElement&#x27;s class as a whole String. Cleaning up any previous classes.
        *
        * Alias for this.className = value
        *
        * @method setClassName
        * @param value {Any} the value that belongs to &#x60;key&#x60;
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.setClassName = function(value) {
            this.className = value;
            return this;
        };

        /**
         * Stores arbitary &#x60;data&#x60; at the HtmlElement. This has nothing to do with node-attributes whatsoever,
         * it is just a way to bind any data to the specific Element so it can be retrieved later on with &#x60;getData()&#x60;.
         *
         * @method setData
         * @param key {string} name of the key
         * @param value {Any} the value that belongs to &#x60;key&#x60;
         * @chainable
         * @since 0.0.1
        */
        ElementPrototype.setData = function(key, value) {
            var instance = this;
            instance._data ||  Object.defineProperty(instance, &#x27;_data&#x27;, {
                configurable: false,
                enumerable: false,
                writable: false,
                value: {} // &#x60;writable&#x60; is false means we cannot chance the value-reference, but we can change {}&#x27;s properties itself
            });
            instance._data[key] = value;
            return instance;
        };

       /**
        * Sets the content of the HtmlElement (innerHTML). Careful: only set content like this if you controll the data and
        * are sure what is going inside. Otherwise XSS might occur. If you let the user insert, or insert right from a db,
        * you might be better of using setContent().
        *
        * @method setHTML
        * @param content {HtmlElement|HtmlElementList|String} content to append
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.setHTML = function(content) {
            this.innerHTML = content;
            return this;
        };

       /**
        * Sets a css-property (inline) out of the HtmlElement. Use camelCase.
        *
        * Note: no need to camelCase cssProperty: both &#x60;margin-left&#x60; as well as &#x60;marginLeft&#x60; are fine
        *
        * @method setStyle
        * @param cssAttribute {String} the css-property to be set
        * @param value {String} the css-value
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.setInlineStyle = function(cssAttribute, value) {
            var instance = this;
            // cautious: in case of preserved words (fe &#x60;float&#x60;), we need to modify the attributename
            // in order to get it processed. It should be translated into &#x60;cssFloat&#x60; or alike.
            RESERVED_WORDS[cssAttribute] &amp;&amp; (cssAttribute=&#x27;css-&#x27;+cssAttribute); // will be camelCased in the next step
            instance.style[toCamelCase(cssAttribute)] = String(value).replace(/;$/, &#x27;&#x27;);
            (instance.style.length===0) &amp;&amp; instance.removeAttr(&#x27;style&#x27;);
            return instance;
        };

       /**
        * Sets the content of the HtmlElement. This is a safe way to set the content, because HTML is not parsed.
        * If you do need to set HTML inside the node, use setHTML().
        *
        * @method setText
        * @param content {HtmlElement|HtmlElementList|String} content to append. In case of HTML, it will be escaped.
        * @param [escape] {Boolean} whether to insert &#x60;escaped&#x60; content, leading it into only text inserted
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.setText = function(content) {
            var instance = this;
            // IE8- do not have &#x60;textContent&#x60;, but they do have &#x60;innerText&#x60;
            if (documentElement.textContent) {
                instance.textContent = content;
            }
            else {
                instance.innerText = content;
            }
            return instance;
        };

       /**
        * Sets the value of the following HtmlElements:
        *
        * &lt;ul&gt;
        *     &lt;li&gt;input&lt;/li&gt;
        *     &lt;li&gt;textarea&lt;/li&gt;
        *     &lt;li&gt;select&lt;/li&gt;
        *     &lt;li&gt;any container that is &#x60;contenteditable&#x60;&lt;/li&gt;
        *
        * Will fire an &#x60;valuechange&#x60; event, in case both the &#x60;itsa/event&#x60; as well as
        * &#x60;itsa/event-dom/extra/event-valuechange.js&#x60; are used.
        *
        * Therefore it is highly suggested to use &#x60;setValue()&#x60; instead of setting the value manually.
        *
        * @method setValue
        * @param value {Any} the value to be set
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.setValue = function(value) {
            var instance = this;
            // cautious: input and textarea must be accessed by their propertyname:
            // input.getAttribute(&#x27;value&#x27;) would return the defualt-value instead of actusl
            // and textarea.getAttribute(&#x27;value&#x27;) doesn&#x27;t exist
            var editable = ((editable=instance.getAttr(&#x27;contenteditable&#x27;)) &amp;&amp; (editable!==&#x27;false&#x27;));
            if (editable) {
                instance.innerHTML = value;
            }
            else {
                instance.value = value;
            }
            // if &#x60;document._emitVC&#x60; is available, then invoke it to emit the &#x60;valuechange&#x60;-event
            window.document._emitVC &amp;&amp; window.document._emitVC(instance, value);
            return instance;
        };

        /**
         * Set the X position of an html element in page coordinates, regardless of how the element is positioned.
         * The element(s) must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @method setX
         * @param element The target element
         * @param {Number} x The X values for new position (coordinates are page-based)
         */
        ElementPrototype.setX = function(node, x) {
            return this.setXY(x);
        };

       /**
         * Set the position of an html element in page coordinates.
         * The element must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         *
         * If the HtmlElement has the attribute &#x60;xy-constrian&#x60; set, then its position cannot exceed any matching container it lies within.
         *
         * @method setXY
         * @param x {Number} x-value for new position (coordinates are page-based)
         * @param y {Number} y-value for new position (coordinates are page-based)
         * @param [constrain] {&#x27;window&#x27;, HtmlElement, Object, String}
         * &lt;ul&gt;
         *     &lt;li&gt;&lt;b&gt;&#x27;window&#x27;&lt;/b&gt; to constrain to the visible window&lt;/li&gt;
         *     &lt;li&gt;&lt;b&gt;HtmlElement&lt;/b&gt; to constrain to a specified HtmlElement&lt;/li&gt;
         *     &lt;li&gt;&lt;b&gt;Object&lt;/b&gt; to constrain to an object with the properties: {x, y, w, h} where x and y are absolute pixels of the document
         *            (like calculated with getX() and getY()).&lt;/li&gt;
         *     &lt;li&gt;&lt;b&gt;String&lt;/b&gt; to constrain to a specified css-selector, which should be an ancestor&lt;/li&gt;
         * &lt;/ul&gt;
         * @param [notransition=false] {Boolean} set true if you are sure positioning is without transition.
         *        this isn&#x27;t required, but it speeds up positioning. Only use when no transition is used:
         *        when there is a transition, setting this argument &#x60;true&#x60; would miscalculate the position.
         * @chainable
         * @since 0.0.2
         */
        ElementPrototype.setXY = function(x, y, constrain, notransition) {
            console.log(NAME, &#x27;setXY &#x27;+x+&#x27;,&#x27;+y);
            var instance = this,
                position = instance.getStyle(POSITION),
                dif, match, constrainNode, byExactId, parent, clone,
                containerTop, containerRight, containerLeft, containerBottom, requestedX, requestedY;

            // default position to relative
            if (position===&#x27;static&#x27;) {
                instance.setInlineStyle(POSITION, &#x27;relative&#x27;);
            }
            // make sure it has sizes and can be positioned
            instance.setClass(INVISIBLE).setClass(BORDERBOX);
            (instance.getInlineStyle(&#x27;display&#x27;)===&#x27;none&#x27;) &amp;&amp; instance.setClass(BLOCK);
            if (constrain) {
                if (constrain===&#x27;window&#x27;) {
                    containerLeft = window.getScrollLeft();
                    containerTop = window.getScrollTop();
                    containerRight = containerLeft + window.getWidth();
                    containerBottom = containerTop + window.getHeight();
                }
                else {
                    if (typeof constrain === &#x27;string&#x27;) {
                        match = false;
                        constrainNode = instance.parentNode;
                        byExactId = REGEXP_NODE_ID.test(constrain);
                        while (constrainNode.matchesSelector &amp;&amp; !match) {
                            match = byExactId ? (constrainNode.id===constrain.substr(1)) : constrainNode.matchesSelector(constrain);
                            // if there is a match, then make sure x and y fall within the region
                            match || (constrainNode=constrainNode.parentNode);
                        }
                        // if HtmlElement found, then bound it to &#x60;constrain&#x60; as if the argument &#x60;constrain&#x60; was an HtmlElement
                        match &amp;&amp; (constrain=constrainNode);
                    }
                    if (constrain.matchesSelector) {
                        // HtmlElement --&gt; we need to search the rectangle
                        containerLeft = constrain.getX() + parseInt(constrain.getStyle(BORDER_LEFT_WIDTH), 10);
                        containerTop = constrain.getY() + parseInt(constrain.getStyle(BORDER_TOP_WIDTH), 10);
                        containerRight = containerLeft + constrain.scrollWidth;
                        containerBottom = containerTop + constrain.scrollHeight;
                    }
                    else {
                        containerLeft = constrain.x;
                        containerTop = constrain.y;
                        containerRight = constrain.x + constrain.w;
                        containerBottom = constrain.y + constrain.h;
                    }
                }
                if (typeof containerLeft === NUMBER) {
                    // found constrain, always redefine x and y
                    x = requestedX = (typeof x===NUMBER) ? x : instance.getX();
                    if (requestedX&lt;containerLeft) {
                        x = containerLeft;
                    }
                    else {
                        if ((requestedX+instance.offsetWidth)&gt;containerRight) {
                            x = requestedX = containerRight - instance.offsetWidth;
                        }
                        // now we might need to reset to the left again:
                        (requestedX&lt;containerLeft) &amp;&amp; (x=containerLeft);
                    }
                    y = requestedY = (typeof y===NUMBER) ? y : instance.getY();
                    if (requestedY&lt;containerTop) {
                        y = containerTop;
                    }
                    else {
                        if ((requestedY+instance.offsetHeight)&gt;containerBottom) {
                            y = requestedY = containerBottom - instance.offsetHeight;
                        }
                        // now we might need to reset to the top again:
                        (requestedY&lt;containerTop) &amp;&amp; (y=containerTop);
                    }
                }
            }
            if (typeof x === NUMBER) {
                // check if there is a transition:
                if (notransition) {
                    instance.setClass(INVISIBLE);
                    instance.setInlineStyle(LEFT, x + PX);
                    dif = (instance.getX()-x);
                    (dif!==0) &amp;&amp; (instance.setInlineStyle(LEFT, (x - dif) + PX));
                    instance.removeClass(INVISIBLE);
                }
                else {
                    // we will clone the node, make it invisible and without transitions and look what its correction should be
                    clone = instance.clone();
                    clone.setClass(NO_TRANS).setClass(INVISIBLE);
                    parent = instance.parentNode;
                    parent.append(clone);
                    clone.setInlineStyle(LEFT, x+PX);
                    dif = (clone.getX()-x);
                    parent.removeChild(clone);
                    instance.setInlineStyle(LEFT, (x - dif) + PX);
                }
            }
            if (typeof y === NUMBER) {
                if (notransition) {
                    instance.setClass(INVISIBLE);
                    instance.setInlineStyle(TOP, y + PX);
                    dif = (instance.getY()-y);
                    (dif!==0) &amp;&amp; (instance.setInlineStyle(TOP, (y - dif) + PX));
                    instance.removeClass(INVISIBLE);
                }
                else {
                    // we will clone the node, make it invisible and without transitions and look what its correction should be
                    clone = instance.clone();
                    clone.setClass(NO_TRANS).setClass(INVISIBLE);
                    parent = instance.parentNode;
                    parent.append(clone);
                    clone.setInlineStyle(TOP, y+PX);
                    dif = (clone.getY()-y);
                    parent.removeChild(clone);
                    instance.setInlineStyle(TOP, (y - dif) + PX);
                }
            }
            return instance.removeClass(BLOCK).removeClass(BORDERBOX).removeClass(INVISIBLE);
        };

        /**
         * Set the Y position of an html element in page coordinates, regardless of how the element is positioned.
         * The element(s) must be part of the DOM tree to have page coordinates (display:none or elements not appended return false).
         * @method setY
         * @param element The target element
         * @param {Number} y The Y values for new position (coordinates are page-based)
         */
        ElementPrototype.setY = function(node, y) {
            return this.setXY(null, y);
        };

       /**
        * Tests if the HtmlElement would be selected by the specified cssSelector.
        * Alias for &#x60;matchesSelector()&#x60;
        *
        * @method test
        * @param cssSelector {String} the css-selector to test against
        * @return {Boolean} whether or not the node matches the selector
        * @since 0.0.1
        */
        ElementPrototype.test = function(/* cssSelector */) {
            return window.document.test.apply(this, arguments);
        };

       /**
        * Toggles the className of the Element.
        *
        * @method toggleClass
        * @param className {String|Array} className that should be toggled, may be an array of classNames
        * @param forceState {Boolean} to force toggling into this specific state
        * @chainable
        * @since 0.0.1
        */
        ElementPrototype.toggleClass = function(className, forceState) {
            var instance = this,
                doToggle = function(cl) {
                    (((typeof forceState === &#x27;boolean&#x27;) &amp;&amp; !forceState) || instance.hasClass(cl)) ? instance.removeClass(cl) : instance.setClass(cl);
                };
            if (typeof className === &#x27;string&#x27;) {
                doToggle(className);
            }
            else if (Array.isArray(className)) {
                className.forEach(doToggle);
            }
            return instance;
        };

    }(window.Element.prototype));
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
